# 工厂方法模式

## 意图

定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类中。p110

## 结构图

![image](https://github.com/yantianpi/designMode/raw/master/factory/structure.png)

## 工厂方法中角色介绍

* 抽象工厂（Creator）角色，模式中任何创建对象的工厂都要实现这个接口，它声明了工厂方法，该方法返回一个Product类型的产品
* 具体工厂（ConcreteCreator）角色，实现抽象工厂接口，具体工厂角色与应用有关，由应用直接调用以创建产品对象
* 抽象产品（Product）角色，具体产品对象共有的父类或接口
* 具体产品（ConcreteProduct）角色，实现抽象产品接口，并且工厂方法所创建的对象都是某具体产品对象的实例

## 工厂方法优点

* 将产品的使用和实现解耦

## 工厂方法缺点

* 要得到一个产品，需要先建个具体工厂

## 实现原则

* 依赖倒置原则，依赖抽象，不依赖实现(Creator制作比萨，不依赖具体的比萨类，依赖比萨抽象类)
* 开闭原则，对扩展开放，对修改关闭（当需要在其他地区开pizza店时，只需要添加几个具体pizza类和一个具体工厂，不需要修改原来已有的工厂类，以及使用的客户端）

## 对比

* 简单工厂，在结构上差不多，简单工厂的核心在一个具体类上，工厂方法的核心在一个抽象工厂类上；在新建一个产品对象时，简单工厂需要修改具体类，而工厂方法只需要添加一个具体产品类和一个具体工厂即可，原有工厂不需要修改，也不需要修改已有的客户端，满足开闭原则；简单工厂是工厂方法的退化版
* 抽象工厂，抽象工厂管理多个产品，工厂方法只管理一个产品；抽象工厂使用对象组合，对象的创建被实现在工厂接口暴露的方法中，工厂方法使用继承，子类实现工厂方法创建对象；抽象工厂中创建产品的方法通常利用工厂方法实现；所有工厂模式都是减少应用程序和具体类的依赖，促进松耦合，针对抽象编程，不针对具体类编程

[参考工厂模式](http://www.phppan.com/2010/07/php-design-pattern-9-factory-method/)
[参考抽象工厂](http://www.phppan.com/2010/05/php-design-pattern-3-abstract-factory/)